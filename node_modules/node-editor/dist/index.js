// TODO turn into attributes
const ZOOM_RATE = 0.085;
const MIN_ZOOM = 0.2; // CANNOT BE ZERO!
const MAX_ZOOM = 1;
const GRID_RESOLUTION = 32;
const GRID_DOT_RADIUS = 1.5;
const PATH_WIDTH = 5;
const PATH_TENSION = 0.5;
const MIN_PATH_TENSION = 50.0;
const MAX_INVERTED_PATH_TENSION = 300;
const DEFAULT_PORT_RADIUS = 7;
const DEFAULT_PORT_COLOR = '#555';
const HTML = document.createElement.bind(document);
function SVG(tag) {
    return document.createElementNS('http://www.w3.org/2000/svg', tag);
}
function roundTo(v, to) {
    return Math.ceil(v / to) * to;
}
function attr(elem, map) {
    for (const k of Object.keys(map)) {
        const v = map[k];
        if (v === null) {
            elem.removeAttribute(k);
        }
        else if (typeof v === 'object') {
            for (const nsk of Object.keys(v)) {
                const nsv = v[nsk];
                if (nsv === null) {
                    elem.removeAttributeNS(k, nsk);
                }
                else {
                    elem.setAttributeNS(k, nsk, nsv.toString());
                }
            }
        }
        else {
            elem.setAttribute(k, v.toString());
        }
    }
    return elem;
}
function setLinkCurve(elem, x1, y1, x2, y2) {
    x1 = roundTo(x1, 0.1);
    y1 = roundTo(y1, 0.1);
    x2 = roundTo(x2, 0.1);
    y2 = roundTo(y2, 0.1);
    const hDist = x2 - x1;
    const t = roundTo(Math.max(MIN_PATH_TENSION, Math.abs(Math.max(-MAX_INVERTED_PATH_TENSION, hDist * PATH_TENSION))), 0.1);
    elem.setAttribute('d', `M${x1} ${y1}C${x1 + t} ${y1} ${x2 - t} ${y2} ${x2} ${y2}`);
}
function upgradeAll(self, tagName, childType) {
    const children = self.getElementsByTagName(tagName);
    for (let i = 0, len = children.length; i < len; i++) {
        const child = children.item(i);
        if (child instanceof childType) {
            child.disconnectedCallback();
            child.connectedCallback();
        }
    }
}
function createDebouncedResizeObserver(cb) {
    let lastWidth = Infinity;
    let lastHeight = Infinity;
    let ignoreResize = null;
    const resizeObserver = new ResizeObserver(([{ contentRect, target }]) => {
        if (ignoreResize !== null) {
            ignoreResize = null;
            return;
        }
        const newWidth = contentRect.width;
        const newHeight = contentRect.height;
        if (newWidth === lastWidth && newHeight === lastHeight)
            return;
        lastWidth = newWidth;
        lastHeight = newHeight;
        try {
            resizeObserver.unobserve(target);
            cb(newWidth, newHeight);
        }
        finally {
            const token = Math.random();
            ignoreResize = token;
            setTimeout(() => {
                if (ignoreResize === token)
                    ignoreResize = null;
            }, 0);
            resizeObserver.observe(target);
        }
    });
    return resizeObserver;
}
// Upgrades properties on custom elements that might have
// been primitively set prior to the prototype attachment.
function upgradeProperties() {
    const props = (this.constructor.observedAttributes);
    if (props) {
        for (const prop of props) {
            if (this.hasOwnProperty(prop)) {
                const value = this[prop];
                delete this[prop];
                this[prop] = value;
            }
        }
    }
}
function findAncestorOfType(from, type) {
    let cur = from;
    do {
        if (cur instanceof type) {
            return cur;
        }
        cur = cur.parentNode;
    } while (cur && cur !== document.body);
    return;
}
// Private members
const internal = Symbol();
const updateTransform = Symbol();
const refreshPosition = Symbol();
const refreshColor = Symbol();
const refreshConnection = Symbol();
const notifyConnection = Symbol();
class NodeMapViewportStartEvent extends Event {
    constructor() {
        super('viewportstart', { bubbles: true });
    }
}
class NodeMapViewportStopEvent extends Event {
    constructor() {
        super('viewportstop', { bubbles: true });
    }
}
class NodeMapViewportEvent extends Event {
    constructor(offsetX, offsetY, zoom) {
        super('viewport', { bubbles: true });
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.zoom = zoom;
    }
}
class NodeEditorTransformEvent extends Event {
    constructor(opts) {
        super('transform', { bubbles: true });
        this.x = opts.x;
        this.y = opts.y;
        this.width = opts.width;
        this.height = opts.height;
        this.didResize = opts.didResize;
        this.didMove = opts.didMove;
    }
}
class NodePortPositionEvent extends Event {
    constructor(x, y) {
        super('position', { bubbles: true });
        this.x = x;
        this.y = y;
    }
}
class NodePortColorEvent extends Event {
    constructor(color) {
        super('color', { bubbles: true });
        this.color = color;
    }
}
class NodePortOnlineEvent extends Event {
    constructor(port) {
        super('online', { bubbles: true });
        this.port = port;
    }
}
class NodePortOfflineEvent extends Event {
    constructor(port) {
        super('offline', { bubbles: true });
        this.port = port;
    }
}
class NodeEditorAddEvent extends Event {
    constructor(editor) {
        super('add', { bubbles: true });
        this.editor = editor;
    }
}
class NodeEditorRemoveEvent extends Event {
    constructor(editor) {
        super('remove', { bubbles: true });
        this.editor = editor;
    }
}
class NodeNameEvent extends Event {
    constructor(name, oldName) {
        super('name', { bubbles: true });
        this.name = name;
        this.oldName = oldName;
    }
}
class NodeLinkEvent extends Event {
    constructor(link) {
        super('link', { bubbles: true });
        this.link = link;
    }
}
class NodeUnlinkEvent extends Event {
    constructor(link) {
        super('unlink', { bubbles: true });
        this.link = link;
    }
}
class NodeConnectEvent extends Event {
    constructor(link, bubbles) {
        super('connect', { bubbles });
        this.link = link;
    }
}
class NodeDisconnectEvent extends Event {
    constructor(link, bubbles) {
        super('disconnect', { bubbles });
        this.link = link;
    }
}
class NodePortElement extends HTMLElement {
    constructor() {
        super();
        const shadow = this.attachShadow({
            mode: 'closed'
        });
        upgradeProperties.call(this);
        const root = HTML('span');
        const I = (this[internal] = {
            root,
            portMarker: HTML('span'),
            resizeObserver: createDebouncedResizeObserver(() => this[refreshPosition]()),
            defaultPortMarker: HTML('span'),
            handleSlot: attr(HTML('slot'), {
                name: 'handle'
            }),
            handlePosition: [0, 0],
            connections: new Set()
        });
        Object.assign(I.portMarker.style, {
            position: 'absolute',
            userSelect: 'none',
            cursor: 'pointer'
        });
        I.portMarker.appendChild(I.handleSlot);
        shadow.appendChild(root);
        shadow.appendChild(I.portMarker);
        root.appendChild(HTML('slot'));
        Object.assign(I.defaultPortMarker.style, {
            display: 'inline-block',
            borderRadius: '50%',
            width: `${DEFAULT_PORT_RADIUS * 2}px`,
            height: `${DEFAULT_PORT_RADIUS * 2}px`,
            backgroundColor: 'var(--port-color)',
            border: 'solid 1px #1115'
        });
        I.handleSlot.addEventListener('slotchange', () => {
            if (I.handleSlot.assignedNodes().length === 0) {
                I.portMarker.appendChild(I.defaultPortMarker);
            }
            else {
                I.defaultPortMarker.remove();
            }
        });
        I.portMarker.appendChild(I.defaultPortMarker);
        this[refreshPosition]();
        this[refreshColor]();
        this.addEventListener('connect', e => {
            I.connections.add(e.link);
            this.setAttribute('connections', I.connections.size.toString());
        });
        this.addEventListener('disconnect', e => {
            I.connections.delete(e.link);
            const count = I.connections.size;
            if (count > 0) {
                this.setAttribute('connections', count.toString());
            }
            else {
                this.removeAttribute('connections');
            }
        });
    }
    static get observedAttributes() {
        return ['name', 'color', 'out'];
    }
    get numConnections() {
        return this[internal].connections.size;
    }
    get connections() {
        return [...this[internal].connections];
    }
    get name() {
        return this.getAttribute('name');
    }
    set name(v) {
        if (v === null)
            this.removeAttribute('name');
        else
            this.setAttribute('name', v);
    }
    get nodeEditor() {
        var _a;
        return (_a = this[internal].editor) !== null && _a !== void 0 ? _a : null;
    }
    get color() {
        return this.getAttribute('color') || DEFAULT_PORT_COLOR;
    }
    set color(v) {
        if (v === null)
            this.removeAttribute('color');
        else
            this.setAttribute('color', v);
    }
    get isOutputPort() {
        return this.hasAttribute('out');
    }
    set isOutputPort(v) {
        this.removeAttribute('out');
        if (v) {
            this.setAttribute('out', '');
        }
    }
    get handleX() {
        return this[internal].handlePosition[0];
    }
    get handleY() {
        return this[internal].handlePosition[1];
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'out':
                this[refreshPosition]();
                break;
            case 'color':
                this[refreshColor]();
                break;
            case 'name': {
                if (oldValue !== newValue) {
                    this.dispatchEvent(new NodeNameEvent(newValue, oldValue));
                }
                break;
            }
        }
    }
    [refreshColor]() {
        const I = this[internal];
        I.portMarker.style.setProperty('--port-color', this.color);
        this.dispatchEvent(new NodePortColorEvent(this.color));
    }
    [refreshPosition]() {
        const I = this[internal];
        if (!I.editor)
            return;
        const marker = I.handleSlot.assignedNodes().length > 0
            ? I.portMarker
            : I.defaultPortMarker;
        const { y: editorY, x: editorX, width: editorWidth } = I.editor;
        const { height: portHeight } = I.root.getBoundingClientRect();
        const portY = I.root.offsetTop;
        const { width: markerWidth, height: markerHeight } = marker.getBoundingClientRect();
        let xPos = this.hasAttribute('out') ? editorWidth : 0;
        let yPos = portY - editorY + portHeight / 2;
        Object.assign(I.portMarker.style, {
            position: 'absolute',
            left: `${xPos - markerWidth / 2}px`,
            top: `${yPos - markerHeight / 2}px`
        });
        I.handlePosition = [xPos + editorX, yPos + editorY];
        this.dispatchEvent(new NodePortPositionEvent(xPos, yPos));
    }
    connectedCallback() {
        const I = this[internal];
        I.editor = findAncestorOfType(this, NodeEditorElement);
        I.resizeObserver.observe(this);
        I.resizeObserver.observe(I.portMarker);
        if (I.editor) {
            I.editorResizeAbort = new AbortController();
            I.editor.addEventListener('transform', () => this[refreshPosition](), { passive: true, signal: I.editorResizeAbort.signal });
        }
        this.dispatchEvent(new NodePortOnlineEvent(this));
        this[refreshPosition]();
    }
    disconnectedCallback() {
        var _a;
        const I = this[internal];
        I.resizeObserver.unobserve(this);
        I.resizeObserver.unobserve(I.portMarker);
        if (I.editorResizeAbort) {
            I.editorResizeAbort.abort();
            delete I.editorResizeAbort;
        }
        const ev = new NodePortOfflineEvent(this);
        this.dispatchEvent(ev);
        if (ev.bubbles && !ev.cancelBubble)
            (_a = I.editor) === null || _a === void 0 ? void 0 : _a.dispatchEvent(ev);
        delete I.editor;
    }
}
class NodeTitleElement extends HTMLElement {
    constructor() {
        super();
        this[internal] = {};
        let dragId = null;
        let dragStart = [0, 0, 0, 0];
        const onDrag = (e) => {
            var _a, _b, _c;
            const I = this[internal];
            const editor = I.editor;
            const zoom = (_c = (_b = (_a = I.editor) === null || _a === void 0 ? void 0 : _a.nodeMap) === null || _b === void 0 ? void 0 : _b.zoom) !== null && _c !== void 0 ? _c : 1;
            if (editor) {
                editor.x = dragStart[0] + (e.clientX - dragStart[2]) / zoom;
                editor.y = dragStart[1] + (e.clientY - dragStart[3]) / zoom;
            }
        };
        this.addEventListener('pointerdown', e => {
            if (dragId !== null)
                return;
            if (e.button !== 0)
                return;
            const editor = this[internal].editor;
            if (!editor)
                return;
            const abortController = new AbortController();
            dragStart = [editor.x, editor.y, e.clientX, e.clientY];
            this.classList.add('dragging');
            this.setPointerCapture(e.pointerId);
            this.addEventListener('pointermove', onDrag, {
                signal: abortController.signal
            });
            dragId = e.pointerId;
            document.addEventListener('pointerup', e => {
                if (e.pointerId !== dragId)
                    return;
                this.classList.remove('dragging');
                this.releasePointerCapture(e.pointerId);
                dragId = null;
                abortController.abort();
            }, { signal: abortController.signal });
        });
    }
    get nodeEditor() {
        var _a;
        return (_a = this[internal].editor) !== null && _a !== void 0 ? _a : null;
    }
    connectedCallback() {
        const I = this[internal];
        I.editor = findAncestorOfType(this, NodeEditorElement);
    }
    disconnectedCallback() {
        const I = this[internal];
        delete I.editor;
    }
}
class NodeEditorElement extends HTMLElement {
    constructor() {
        super();
        const shadow = this.attachShadow({
            mode: 'closed'
        });
        upgradeProperties.call(this);
        const I = (this[internal] = {
            root: attr(HTML('div'), {
                part: 'frame'
            }),
            resizeObserver: createDebouncedResizeObserver(() => this[updateTransform](true, false)),
            ports: new Map()
        });
        Object.assign(I.root.style, {
            position: 'absolute',
            boxSizing: 'border-box'
        });
        I.root.appendChild(HTML('slot'));
        shadow.appendChild(I.root);
        this.addEventListener('online', e => {
            const I = this[internal];
            const port = e.port;
            if (port.name) {
                const existing = I.ports.get(port.name);
                if (existing && existing !== port) {
                    console.warn('ignoring port with duplicate name:', port.name);
                    return;
                }
                I.ports.set(port.name, port);
            }
        });
        this.addEventListener('offline', e => {
            const I = this[internal];
            const port = e.port;
            if (port.name) {
                const existing = I.ports.get(port.name);
                if (existing && existing === port) {
                    I.ports.delete(port.name);
                }
            }
        });
        this.addEventListener('name', e => {
            const I = this[internal];
            const { target, oldName } = e;
            if (target instanceof NodePortElement) {
                if (oldName) {
                    const existing = I.ports.get(oldName);
                    if (existing && existing === target) {
                        I.ports.delete(oldName);
                    }
                }
                if (target.name) {
                    const existing = I.ports.get(target.name);
                    if (existing && existing !== target) {
                        console.warn('ignoring port with duplicate name:', target.name);
                    }
                    else {
                        I.ports.set(target.name, target);
                    }
                }
            }
        });
    }
    static get observedAttributes() {
        return ['name', 'x', 'y', 'width', 'height'];
    }
    getPort(name) {
        var _a;
        return (_a = this[internal].ports.get(name)) !== null && _a !== void 0 ? _a : null;
    }
    connectedCallback() {
        const I = this[internal];
        I.map = findAncestorOfType(this, NodeMapElement);
        this.dispatchEvent(new NodeEditorAddEvent(this));
        upgradeAll(this, 'node-port', NodePortElement);
        upgradeAll(this, 'node-title', NodeTitleElement);
        I.resizeObserver.observe(I.root);
    }
    disconnectedCallback() {
        var _a;
        const I = this[internal];
        const ev = new NodeEditorRemoveEvent(this);
        this.dispatchEvent(ev);
        if (ev.bubbles && !ev.cancelBubble)
            (_a = I.map) === null || _a === void 0 ? void 0 : _a.dispatchEvent(ev);
        delete I.map;
        I.resizeObserver.unobserve(I.root);
    }
    get nodeMap() {
        var _a;
        return (_a = this[internal].map) !== null && _a !== void 0 ? _a : null;
    }
    get x() {
        return parseInt(this.getAttribute('x') || '0', 10);
    }
    set x(v) {
        if (v === null)
            this.removeAttribute('x');
        else
            this.setAttribute('x', v.toString());
    }
    get y() {
        return parseInt(this.getAttribute('y') || '0', 10);
    }
    set y(v) {
        if (v === null)
            this.removeAttribute('y');
        else
            this.setAttribute('y', v.toString());
    }
    get name() {
        return this.getAttribute('name');
    }
    set name(v) {
        if (v === null)
            this.removeAttribute('name');
        else
            this.setAttribute('name', v);
    }
    get width() {
        const attributeValue = this.getAttribute('width');
        return attributeValue === null
            ? this[internal].root.getBoundingClientRect().width
            : parseInt(attributeValue, 10);
    }
    set width(v) {
        if (v === null)
            this.removeAttribute('width');
        else
            this.setAttribute('width', v.toString());
    }
    get height() {
        const attributeValue = this.getAttribute('height');
        return attributeValue === null
            ? this[internal].root.getBoundingClientRect().height
            : parseInt(attributeValue, 10);
    }
    set height(v) {
        if (v === null)
            this.removeAttribute('height');
        else
            this.setAttribute('height', v.toString());
    }
    attributeChangedCallback(name, oldValue, newValue) {
        switch (name) {
            case 'x':
            case 'y':
                this[updateTransform](false, true);
                break;
            case 'width':
            case 'height':
                this[updateTransform](true, false);
                break;
            case 'name':
                if (newValue !== oldValue) {
                    this.dispatchEvent(new NodeNameEvent(newValue, oldValue));
                }
                break;
        }
    }
    [updateTransform](didResize, didMove) {
        const I = this[internal];
        I.root.style.left = `${this.x}px`;
        I.root.style.top = `${this.y}px`;
        const maybeWidth = this.getAttribute('width');
        if (maybeWidth !== null)
            I.root.style.width = `${parseInt(maybeWidth, 10)}px`;
        const maybeHeight = this.getAttribute('height');
        if (maybeHeight !== null)
            I.root.style.height = `${parseInt(maybeHeight, 10)}px`;
        // force re-layout
        void I.root.offsetWidth;
        this.dispatchEvent(new NodeEditorTransformEvent({
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            didResize,
            didMove
        }));
    }
}
class NodeLinkElement extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'closed' });
        upgradeProperties.call(this);
        // *sigh*
        const gradId = `linkgrad${Math.random().toString().slice(2)}`;
        const I = (this[internal] = {
            elem: SVG('g'),
            rootElem: SVG('g'),
            pathElem: attr(SVG('path'), {
                part: 'link',
                stroke: `url(#${gradId})`,
                'stroke-width': PATH_WIDTH,
                fill: 'none',
                d: 'M0,0'
            }),
            fromColorElem: attr(SVG('stop'), {
                offset: '25%',
                'stop-color': DEFAULT_PORT_COLOR
            }),
            toColorElem: attr(SVG('stop'), {
                offset: '75%',
                'stop-color': DEFAULT_PORT_COLOR
            }),
            fromPort: null,
            toPort: null,
            gradientElem: attr(SVG('linearGradient'), {
                id: gradId,
                gradientUnits: 'userSpaceOnUse',
                x1: '0',
                y1: '0',
                x2: '0',
                y2: '0'
            }),
            connected: false
        });
        I.gradientElem.appendChild(I.fromColorElem);
        I.gradientElem.appendChild(I.toColorElem);
        I.rootElem.appendChild(I.gradientElem);
        I.rootElem.appendChild(I.pathElem);
    }
    static get observedAttributes() {
        return ['from', 'in', 'to', 'out'];
    }
    get nodeMap() {
        var _a;
        return (_a = this[internal].map) !== null && _a !== void 0 ? _a : null;
    }
    get fromName() {
        return this.getAttribute('from') || null;
    }
    set fromName(v) {
        if (v === null)
            this.removeAttribute('from');
        else
            this.setAttribute('from', v);
    }
    get toName() {
        return this.getAttribute('to') || null;
    }
    set toName(v) {
        if (v === null)
            this.removeAttribute('to');
        else
            this.setAttribute('to', v);
    }
    get inName() {
        var _a;
        return (_a = this.getAttribute('in')) !== null && _a !== void 0 ? _a : null;
    }
    set inName(v) {
        if (v === null)
            this.removeAttribute('in');
        else
            this.setAttribute('in', v);
    }
    get outName() {
        var _a;
        return (_a = this.getAttribute('out')) !== null && _a !== void 0 ? _a : null;
    }
    set outName(v) {
        if (v === null)
            this.removeAttribute('out');
        else
            this.setAttribute('out', v);
    }
    get inPort() {
        return this[internal].toPort;
    }
    get outPort() {
        return this[internal].fromPort;
    }
    [notifyConnection](connected, fromPort, toPort) {
        var _a;
        const I = this[internal];
        if (I.connected === connected)
            return;
        if (connected) {
            this.dispatchEvent(new NodeConnectEvent(this, true));
            fromPort.dispatchEvent(new NodeConnectEvent(this, false));
            toPort.dispatchEvent(new NodeConnectEvent(this, false));
        }
        else {
            const ev = new NodeDisconnectEvent(this, true);
            this.dispatchEvent(ev);
            if (!this.parentNode && !ev.cancelBubble) {
                (_a = I.map) === null || _a === void 0 ? void 0 : _a.dispatchEvent(ev);
            }
            if (fromPort)
                fromPort.dispatchEvent(new NodeDisconnectEvent(this, false));
            if (toPort)
                toPort.dispatchEvent(new NodeDisconnectEvent(this, false));
        }
        I.connected = connected;
    }
    [refreshConnection](forceDisconnect = false) {
        var _a;
        const I = this[internal];
        let newFromEditor;
        let newToEditor;
        let newFromPort;
        let newToPort;
        try {
            this[notifyConnection](false, I.fromPort, I.toPort);
            I.rootElem.remove();
            (_a = I.refreshAbort) === null || _a === void 0 ? void 0 : _a.abort();
            const map = I.map;
            if (!map || forceDisconnect)
                return;
            const { toName, fromName, inName, outName } = this;
            if (!(toName && fromName && inName && outName))
                return;
            newFromEditor = map.getEditor(fromName);
            newToEditor = map.getEditor(toName);
            if (!newFromEditor || !newToEditor)
                return;
            newFromPort = newFromEditor.getPort(outName);
            newToPort = newToEditor.getPort(inName);
            if (!newFromPort || !newToPort)
                return;
        }
        finally {
            I.fromPort = null;
            I.toPort = null;
        }
        I.refreshAbort = new AbortController();
        newFromPort.addEventListener('position', () => this[refreshPosition](), {
            passive: true,
            signal: I.refreshAbort.signal
        });
        newToPort.addEventListener('position', () => this[refreshPosition](), {
            passive: true,
            signal: I.refreshAbort.signal
        });
        newFromPort.addEventListener('offline', () => this.remove(), {
            signal: I.refreshAbort.signal
        });
        newToPort.addEventListener('offline', () => this.remove(), {
            signal: I.refreshAbort.signal
        });
        newFromPort.addEventListener('color', () => this[refreshColor](), {
            signal: I.refreshAbort.signal
        });
        newToPort.addEventListener('color', () => this[refreshColor](), {
            signal: I.refreshAbort.signal
        });
        newFromPort.addEventListener('name', () => this[refreshConnection](true), {
            signal: I.refreshAbort.signal
        });
        newToPort.addEventListener('name', () => this[refreshConnection](true), {
            signal: I.refreshAbort.signal
        });
        newFromEditor.addEventListener('name', () => this[refreshConnection](true), {
            signal: I.refreshAbort.signal
        });
        newToEditor.addEventListener('name', () => this[refreshConnection](true), {
            signal: I.refreshAbort.signal
        });
        I.fromPort = newFromPort;
        I.toPort = newToPort;
        this[refreshPosition]();
        this[refreshColor]();
        I.rootElem.addEventListener('mousedown', e => e.preventDefault(), {
            signal: I.refreshAbort.signal
        });
        I.rootElem.addEventListener('dblclick', e => {
            e.preventDefault();
            e.stopPropagation();
            this.remove();
        }, {
            signal: I.refreshAbort.signal
        });
        I.elem.appendChild(I.rootElem);
        return void this[notifyConnection](true, I.fromPort, I.toPort);
    }
    [refreshPosition]() {
        const I = this[internal];
        const from = I.fromPort;
        const to = I.toPort;
        if (!from || !to) {
            I.pathElem.setAttribute('d', 'M0 0');
            return;
        }
        attr(I.gradientElem, {
            x1: from.handleX,
            y1: from.handleY,
            x2: to.handleX,
            y2: to.handleY
        });
        setLinkCurve(I.pathElem, from.handleX, from.handleY, to.handleX, to.handleY);
    }
    [refreshColor]() {
        var _a, _b, _c, _d;
        const I = this[internal];
        I.fromColorElem.setAttribute('stop-color', (_b = (_a = I.fromPort) === null || _a === void 0 ? void 0 : _a.color) !== null && _b !== void 0 ? _b : DEFAULT_PORT_COLOR);
        I.toColorElem.setAttribute('stop-color', (_d = (_c = I.toPort) === null || _c === void 0 ? void 0 : _c.color) !== null && _d !== void 0 ? _d : DEFAULT_PORT_COLOR);
    }
    attributeChangedCallback() {
        this.dispatchEvent(new NodeUnlinkEvent(this));
        this.dispatchEvent(new NodeLinkEvent(this));
        this[refreshConnection]();
    }
    connectedCallback() {
        const I = this[internal];
        I.map = findAncestorOfType(this, NodeMapElement);
        this.dispatchEvent(new NodeLinkEvent(this));
        this[refreshConnection]();
    }
    disconnectedCallback() {
        var _a;
        const I = this[internal];
        const ev = new NodeUnlinkEvent(this);
        this.dispatchEvent(ev);
        if (ev.bubbles && !ev.cancelBubble)
            (_a = I.map) === null || _a === void 0 ? void 0 : _a.dispatchEvent(ev);
        this[refreshConnection](true);
        delete I.map;
    }
}
class NodeCanvas extends EventTarget {
    constructor() {
        super();
        this.elem = SVG('svg');
        this.root = SVG('svg');
        this.pattern = SVG('pattern');
        this.width = 0;
        this.height = 0;
        this.panX = 0;
        this.panY = 0;
        this.zoom = 1;
        this.elem.classList.add('node-canvas-base');
        this.root.classList.add('node-canvas-root');
        this.root.style.overflow = 'visible';
        const bgDot = attr(SVG('circle'), {
            fill: 'rgba(127,127,127,0.3)',
            r: GRID_DOT_RADIUS,
            cx: GRID_DOT_RADIUS,
            cy: GRID_DOT_RADIUS
        });
        const bgRect = attr(SVG('rect'), {
            fill: 'url(#nodebg)',
            width: '100%',
            height: '100%'
        });
        let dragging = false;
        let dragStart = [0, 0, 0, 0];
        const onDrag = (e) => {
            const newX = dragStart[0] + (e.clientX - dragStart[2]) / this.zoom;
            const newY = dragStart[1] + (e.clientY - dragStart[3]) / this.zoom;
            this.setPan(newX, newY);
        };
        this.elem.addEventListener('mousedown', e => e.preventDefault());
        this.elem.addEventListener('pointerdown', e => {
            if (dragging)
                return;
            if (e.button !== 0 && e.button !== 1)
                return;
            if (e.target !== this.elem &&
                e.target !== this.root &&
                e.target !== bgRect) {
                return;
            }
            dragStart = [this.panX, this.panY, e.clientX, e.clientY];
            this.elem.setPointerCapture(e.pointerId);
            this.elem.addEventListener('pointermove', onDrag);
            dragging = true;
            this.dispatchEvent(new NodeMapViewportStartEvent());
        });
        this.elem.addEventListener('pointerup', e => {
            this.elem.releasePointerCapture(e.pointerId);
            this.elem.removeEventListener('pointermove', onDrag);
            dragging = false;
            this.dispatchEvent(new NodeMapViewportStopEvent());
        });
        this.elem.addEventListener('wheel', e => {
            if (dragging)
                return;
            this.pan(-e.clientX / this.zoom, -e.clientY / this.zoom);
            this.setZoom(this.zoom +
                -Math.sign(e.deltaY) *
                    ZOOM_RATE *
                    Math.pow(this.zoom, 0.0001));
            this.pan(e.clientX / this.zoom, e.clientY / this.zoom);
        }, { passive: true });
        this.pattern.id = 'nodebg';
        attr(this.pattern, {
            viewBox: `0 0 ${GRID_RESOLUTION} ${GRID_RESOLUTION}`,
            width: GRID_RESOLUTION,
            height: GRID_RESOLUTION,
            patternUnits: 'userSpaceOnUse'
        });
        this.pattern.appendChild(bgDot);
        this.elem.appendChild(this.pattern);
        this.elem.appendChild(bgRect);
        this.elem.appendChild(this.root);
    }
    appendChild(elem) {
        this.root.appendChild(elem);
    }
    viewToWorld(x, y) {
        return [x / this.zoom - this.panX, y / this.zoom - this.panY];
    }
    worldToView(x, y) {
        return [(x + this.panX) * this.zoom, (y + this.panY) * this.zoom];
    }
    getPan() {
        return [this.panX, this.panY];
    }
    setPan(x, y) {
        this.panX = x;
        this.panY = y;
        attr(this.root, {
            x,
            y
        });
        attr(this.pattern, {
            x,
            y
        });
        this.dispatchEvent(new NodeMapViewportEvent(x, y, this.zoom));
    }
    pan(x, y) {
        this.setPan(this.panX + x, this.panY + y);
    }
    setSize(width, height) {
        this.width = width;
        this.height = height;
        this.updateTransform();
    }
    setZoom(zoom) {
        this.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));
        this.updateTransform();
        this.dispatchEvent(new NodeMapViewportEvent(this.panX, this.panY, this.zoom));
    }
    updateTransform() {
        this.elem.setAttribute('viewBox', `0 0 ${this.width / this.zoom} ${this.height / this.zoom}`);
    }
}
class NodeMapElement extends HTMLElement {
    constructor() {
        super();
        const shadow = this.attachShadow({
            mode: 'closed'
        });
        const I = (this[internal] = {
            canvas: new NodeCanvas(),
            editorCanvas: HTML('div'),
            resizeObserver: createDebouncedResizeObserver((width, height) => this[internal].canvas.setSize(width, height)),
            editors: new Map(),
            links: new Set(),
            ports: new Map(),
            connections: new Map() // TODO actually populate
        });
        const style = HTML('style');
        const root = HTML('div');
        shadow.appendChild(style);
        shadow.appendChild(root);
        root.appendChild(I.canvas.elem);
        root.appendChild(I.editorCanvas);
        I.canvas.elem.setAttribute('part', 'background');
        I.editorCanvas.appendChild(HTML('slot'));
        I.editorCanvas.classList.add('canvas');
        I.canvas.addEventListener('viewport', e => {
            e.stopPropagation();
            const { zoom, offsetX, offsetY } = e;
            const transform = `scale(${zoom}) translate(${offsetX}px, ${offsetY}px)`;
            I.editorCanvas.style.transform = transform;
        });
        I.canvas.addEventListener('viewportstart', e => {
            e.stopPropagation();
            this.classList.add('panning');
        });
        I.canvas.addEventListener('viewportstop', e => {
            e.stopPropagation();
            this.classList.remove('panning');
        });
        style.textContent = `
			:host {
				display: flex;
				flex-wrap: wrap;
				height: 100%;
				overflow: hidden;
			}

			:host > div {
				width: 100%;
				height: 100%;
				position: relative;
				display: block;
				overflow: hidden;
			}

			:host > div > .canvas {
				pointer-events: none;
				transform-origin: top left;
			}

			:host > div > .canvas > * {
				pointer-events: auto;
			}

			:host > div > * {
				position: absolute;
				left: 0;
				top: 0;
				width: 100%;
				height: 100%;
			}
		`;
        const addPort = (port) => {
            if (I.ports.has(port))
                return;
            const controller = new AbortController();
            I.ports.set(port, controller);
            port.addEventListener('pointerdown', e => {
                if (e.button !== 0)
                    return;
                const pointerId = e.pointerId;
                this.setPointerCapture(e.pointerId);
                const dragAbort = new AbortController();
                const linkMarkerElem = attr(SVG('path'), {
                    stroke: port.color,
                    'stroke-width': PATH_WIDTH,
                    fill: 'none',
                    d: `M${port.handleX} ${port.handleY}`
                });
                let lastTargetPort = null;
                dragAbort.signal.addEventListener('abort', () => linkMarkerElem.remove());
                I.canvas.appendChild(linkMarkerElem);
                this.addEventListener('pointermove', e => {
                    const isOut = port.hasAttribute('out');
                    lastTargetPort = null;
                    const maybeElem = document.elementFromPoint(e.pageX, e.pageY);
                    if (maybeElem) {
                        const elem = findAncestorOfType(maybeElem, NodePortElement);
                        if (elem &&
                            elem !== port &&
                            isOut !== elem.hasAttribute('out') &&
                            port.nodeEditor !== elem.nodeEditor) {
                            lastTargetPort = elem;
                        }
                    }
                    const startPoint = [
                        port.handleX,
                        port.handleY
                    ];
                    const endPoint = lastTargetPort
                        ? [
                            lastTargetPort.handleX,
                            lastTargetPort.handleY
                        ]
                        : I.canvas.viewToWorld(e.pageX - this.offsetLeft, e.pageY - this.offsetTop);
                    setLinkCurve(linkMarkerElem, ...(isOut ? startPoint : endPoint), ...(isOut ? endPoint : startPoint));
                }, { signal: dragAbort.signal });
                document.addEventListener('pointerup', e => {
                    var _a, _b, _c;
                    if (e.pointerId !== pointerId)
                        return;
                    this.releasePointerCapture(e.pointerId);
                    dragAbort.abort();
                    if (lastTargetPort &&
                        !((_a = I.connections.get(port)) === null || _a === void 0 ? void 0 : _a.has(lastTargetPort)) &&
                        ((_b = port.nodeEditor) === null || _b === void 0 ? void 0 : _b.name) &&
                        ((_c = lastTargetPort.nodeEditor) === null || _c === void 0 ? void 0 : _c.name) &&
                        port.name &&
                        lastTargetPort.name) {
                        const a = [port.nodeEditor.name, port.name];
                        const b = [
                            lastTargetPort.nodeEditor.name,
                            lastTargetPort.name
                        ];
                        const forward = port.isOutputPort &&
                            !lastTargetPort.isOutputPort;
                        this.appendChild(attr(HTML('node-link'), {
                            from: forward ? a[0] : b[0],
                            to: forward ? b[0] : a[0],
                            out: forward ? a[1] : b[1],
                            in: forward ? b[1] : a[1]
                        }));
                    }
                }, { signal: dragAbort.signal });
            }, { signal: controller.signal });
        };
        const removePort = (port) => {
            if (!I.ports.has(port))
                return;
            I.ports.get(port).abort();
            I.ports.delete(port);
        };
        const createBoundary = (name) => this.addEventListener(name, e => e.stopPropagation());
        createBoundary('transform');
        createBoundary('position');
        createBoundary('color');
        this.addEventListener('connect', e => {
            e.stopPropagation();
            const link = e.link;
            const set = I.connections.get(link.outPort);
            if (set) {
                set.add(link.inPort);
            }
            else {
                I.connections.set(link.outPort, new Set([link.inPort]));
            }
        });
        this.addEventListener('disconnect', e => {
            e.stopPropagation();
            const link = e.link;
            const set = I.connections.get(link.outPort);
            if (set) {
                set.delete(link.inPort);
                if (set.size === 0)
                    I.connections.delete(link.outPort);
            }
        });
        this.addEventListener('online', e => {
            e.stopPropagation();
            const port = e.port;
            addPort(port);
        });
        this.addEventListener('offline', e => {
            e.stopPropagation();
            const port = e.port;
            removePort(port);
        });
        this.addEventListener('add', e => {
            e.stopPropagation();
            const editor = e.editor;
            if (editor.name) {
                const existing = I.editors.get(editor.name);
                if (existing && existing !== editor) {
                    console.warn('ignoring editor with duplicate name:', editor.name);
                    return;
                }
                I.editors.set(editor.name, editor);
            }
        });
        this.addEventListener('remove', e => {
            e.stopPropagation();
            const editor = e.editor;
            if (editor.name) {
                const existing = I.editors.get(editor.name);
                if (existing && existing === editor) {
                    I.editors.delete(editor.name);
                }
            }
        });
        this.addEventListener('name', e => {
            e.stopPropagation();
            const { target, oldName } = e;
            if (target instanceof NodeEditorElement) {
                if (oldName) {
                    const existing = I.editors.get(oldName);
                    if (existing && existing === target) {
                        I.editors.delete(oldName);
                    }
                }
                if (target.name) {
                    const existing = I.editors.get(target.name);
                    if (existing && existing !== target) {
                        console.warn('ignoring editor with duplicate name:', target.name);
                    }
                    else {
                        I.editors.set(target.name, target);
                    }
                }
            }
            else if (target instanceof NodePortElement) {
                if (oldName && !target.name)
                    removePort(target);
                else if (!oldName && target.name)
                    addPort(target);
            }
        });
        this.addEventListener('link', e => {
            e.stopPropagation();
            const link = e.target;
            if (link instanceof NodeLinkElement) {
                const I = this[internal];
                I.links.add(link);
                I.canvas.appendChild(link[internal].elem);
            }
        });
        this.addEventListener('unlink', e => {
            e.stopPropagation();
            const link = e.target;
            if (link instanceof NodeLinkElement) {
                const I = this[internal];
                I.links.delete(link);
                link[internal].elem.remove();
            }
        });
    }
    getEditor(name) {
        var _a;
        return (_a = this[internal].editors.get(name)) !== null && _a !== void 0 ? _a : null;
    }
    get zoom() {
        return this[internal].canvas.zoom;
    }
    connectedCallback() {
        upgradeAll(this, 'node-editor', NodeEditorElement);
        upgradeAll(this, 'node-link', NodeLinkElement);
        this[internal].resizeObserver.observe(this);
    }
    disconnectedCallback() {
        this[internal].resizeObserver.unobserve(this);
    }
}
function defineTag(tag, cls) {
    customElements.define(tag, cls);
    document
        .querySelectorAll(tag)
        .forEach(node => !(node instanceof cls) && customElements.upgrade(node));
}
defineTag('node-map', NodeMapElement);
defineTag('node-editor', NodeEditorElement);
defineTag('node-title', NodeTitleElement);
defineTag('node-port', NodePortElement);
defineTag('node-link', NodeLinkElement);
export { NodeTitleElement, NodePortElement, NodeEditorElement, NodeLinkElement, NodeMapElement, NodeEditorTransformEvent, NodePortPositionEvent, NodePortColorEvent, NodePortOnlineEvent, NodePortOfflineEvent, NodeEditorAddEvent, NodeEditorRemoveEvent, NodeNameEvent, NodeLinkEvent, NodeUnlinkEvent, NodeConnectEvent, NodeDisconnectEvent };
//# sourceMappingURL=index.js.map